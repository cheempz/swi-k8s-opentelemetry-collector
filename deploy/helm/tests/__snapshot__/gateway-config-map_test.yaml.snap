Gateway config should match snapshot when using default values:
  1: |
    gateway.config: "exporters:\n  otlp:\n    endpoint: ${OTEL_ENVOY_ADDRESS}\n    tls:\n      insecure: ${OTEL_ENVOY_ADDRESS_TLS_INSECURE}\n    headers:\n      \"Authorization\": \"Bearer ${SOLARWINDS_API_TOKEN}\"\n    retry_on_failure:\n      enabled: true\n      initial_interval: 10s\n      max_interval: 30s\n      max_elapsed_time: 300s\n    sending_queue:\n      enabled: true\n      num_consumers: 10\n      queue_size: 1000\n    timeout: 30s\n\nextensions:\n  health_check:\n    endpoint: 0.0.0.0:13133\n\nprocessors:\n  batch:\n    send_batch_max_size: 1024\n    send_batch_size: 1024\n    timeout: 1s\n\n  memory_limiter:\n    check_interval: 1s\n    limit_percentage: 80\n    spike_limit_percentage: 25\n\n  k8sattributes:\n    auth_type: \"serviceAccount\"\n    passthrough: false\n    extract:\n      metadata:\n        - k8s.deployment.name\n        - k8s.replicaset.name\n        - k8s.daemonset.name\n        - k8s.job.name\n        - k8s.cronjob.name\n        - k8s.statefulset.name\n        - k8s.node.name\n    pod_association:\n      - sources:\n          - from: resource_attribute\n            name: k8s.pod.name\n          - from: resource_attribute\n            name: k8s.namespace.name\n\n  metricstransform/rename:\n    transforms:\n      # add predefined prefix to all proxied metrics\n      - include: ^(.*)$$\n        match_type: regexp\n        action: update\n        new_name: k8s.$${1}\n\n  resource:\n    attributes:\n      # Collector and Manifest version\n      - key: sw.k8s.agent.manifest.version\n        value: ${MANIFEST_VERSION}\n        action: insert\n\n      - key: sw.k8s.agent.app.version\n        value: ${APP_VERSION}\n        action: insert\n\n      # Cluster\n      - key: sw.k8s.cluster.uid\n        value: ${CLUSTER_UID}\n        action: insert\n\n      - key: k8s.cluster.name\n        value: ${CLUSTER_NAME}\n        action: upsert\n\n  # Those attributes are defined by SWO K8s Collector even if they are send as attributes in OTLP message\n  attributes/clean-attributes-otlp-metrics:\n    actions:\n      - key: k8s.cluster.name\n        action: delete\n\n  transform/scope:\n    metric_statements:\n      - statements:\n        - set(scope.name, \"\")\n        - set(scope.version, \"\")\n    log_statements:\n      - statements:\n        - set(scope.name, \"\")\n        - set(scope.version, \"\")\n    trace_statements:\n      - statements:\n        - set(scope.name, \"\")\n        - set(scope.version, \"\")\n\n  filter/otlp-metrics:\n    metrics:\n      metric:\n        # metrics from EBPF reducer that are not needed\n        - 'IsMatch(name, \"^ebpf_net.*$\")'\n\n  filter/histograms:\n    metrics:\n      metric:\n        - 'type == METRIC_DATA_TYPE_HISTOGRAM'\n\n  filter/beyla_test:\n    metrics:\n      metric:\n        - 'not(name == \"http.client.request.duration\")'\n\n  swok8sworkloadtype/beyla:\n    workload_mappings:\n      - name_attr: k8s.src.owner.name\n        namespace_attr: k8s.src.namespace\n        workload_type_attr: sw.k8s.src.workload.type\n        workload_name_attr: sw.k8s.src.workload.name\n        workload_namespace_attr: sw.k8s.src.workload.namespace\n        prefer_owner_for_pods: true\n        expected_types:\n          - deployments\n          - daemonsets\n          - statefulsets\n          - services\n          - jobs\n          - cronjobs\n          - pods\n          - nodes\n      - name_attr: k8s.dst.owner.name\n        namespace_attr: k8s.dst.namespace\n        workload_type_attr: sw.k8s.dst.workload.type\n        workload_name_attr: sw.k8s.dst.workload.name\n        workload_namespace_attr: sw.k8s.dst.workload.namespace\n        prefer_owner_for_pods: true\n        expected_types:\n          - deployments\n          - daemonsets\n          - statefulsets\n          - services\n          - jobs\n          - cronjobs\n          - pods\n          - nodes\n      - name_attr: resource.k8s.owner.name\n        namespace_attr: resource.k8s.namespace.name\n        workload_type_attr: resource.sw.k8s.workload.type\n        workload_name_attr: resource.sw.k8s.workload.name\n        workload_namespace_attr: resource.sw.k8s.workload.namespace\n        prefer_owner_for_pods: true\n        expected_types:\n          - deployments\n          - daemonsets\n          - statefulsets\n          - services\n          - jobs\n          - cronjobs\n          - pods\n          - nodes\n      - address_attr: server.address\n        namespace_attr: k8s.namespace.name\n        workload_type_attr: sw.k8s.dst.workload.type\n        workload_name_attr: sw.k8s.dst.workload.name\n        workload_namespace_attr: sw.k8s.dst.workload.namespace\n        prefer_owner_for_pods: true\n        expected_types:\n          - services\n          - pods\n      - address_attr: client.address\n        namespace_attr: k8s.namespace.name\n        workload_type_attr: sw.k8s.src.workload.type\n        workload_name_attr: sw.k8s.src.workload.name\n        workload_namespace_attr: sw.k8s.src.workload.namespace\n        prefer_owner_for_pods: true\n        expected_types:\n          - services\n          - pods\n\n  transform/beyla-fqdn-attribute:\n    metric_statements:\n      - statements:\n          # The logic of what shapes of addresses are considered FQDNs should match 'transform/istio-metric-datapoints'.\n          # Also, Beyla prefers filling 'client.address' and 'server.address' attributes with OTEL Service name (or name + k8s namespace) instead of an actual FQDN, when possible. This makes their values useless for us because they would create fake FQDNs.\n          # - set(datapoint.attributes[\"sw.k8s.dst.sw.server.address.fqdn\"], datapoint.attributes[\"server.address\"]) where IsMatch(metric.name, \"^http\\\\.client\\\\.\") and datapoint.attributes[\"sw.k8s.dst.workload.type\"] == nil and IsMatch(datapoint.attributes[\"server.address\"], \"^(https?://)?[a-zA-Z0-9][-a-zA-Z0-9]*\\\\.[a-zA-Z0-9][-a-zA-Z0-9\\\\.]*(:\\\\d+)?$\") and not(IsMatch(datapoint.attributes[\"server.address\"], \".*\\\\.cluster\\\\.local$\")) and not(IsMatch(datapoint.attributes[\"server.address\"], \"^(https?://)?\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+(:\\\\d+)?$\"))\n          # - set(datapoint.attributes[\"sw.k8s.src.sw.server.address.fqdn\"], datapoint.attributes[\"client.address\"]) where IsMatch(metric.name, \"^http\\\\.server\\\\.\") and datapoint.attributes[\"sw.k8s.src.workload.type\"] == nil and IsMatch(datapoint.attributes[\"client.address\"], \"^(https?://)?[a-zA-Z0-9][-a-zA-Z0-9]*\\\\.[a-zA-Z0-9][-a-zA-Z0-9\\\\.]*(:\\\\d+)?$\") and not(IsMatch(datapoint.attributes[\"client.address\"], \".*\\\\.cluster\\\\.local$\")) and not(IsMatch(datapoint.attributes[\"client.address\"], \"^(https?://)?\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+(:\\\\d+)?$\"))\n          # While 'dst.address' and 'src.adderess' contain an actual address, in practice they often contain an IP address, which we currently do not want to use as an FQDN.\n          - set(datapoint.attributes[\"sw.k8s.dst.sw.server.address.fqdn\"], datapoint.attributes[\"dst.address\"]) where IsMatch(metric.name, \"^beyla\\\\.network\\\\.\") and datapoint.attributes[\"sw.k8s.dst.workload.type\"] == nil and IsMatch(datapoint.attributes[\"dst.address\"], \"^(https?://)?[a-zA-Z0-9][-a-zA-Z0-9]*\\\\.[a-zA-Z0-9][-a-zA-Z0-9\\\\.]*(:\\\\d+)?$\") and not(IsMatch(datapoint.attributes[\"dst.address\"], \".*\\\\.cluster\\\\.local$\")) and not(IsMatch(datapoint.attributes[\"dst.address\"], \"^(https?://)?\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+(:\\\\d+)?$\"))\n          - set(datapoint.attributes[\"sw.k8s.src.sw.server.address.fqdn\"], datapoint.attributes[\"src.address\"]) where IsMatch(metric.name, \"^beyla\\\\.network\\\\.\") and datapoint.attributes[\"sw.k8s.src.workload.type\"] == nil and IsMatch(datapoint.attributes[\"src.address\"], \"^(https?://)?[a-zA-Z0-9][-a-zA-Z0-9]*\\\\.[a-zA-Z0-9][-a-zA-Z0-9\\\\.]*(:\\\\d+)?$\") and not(IsMatch(datapoint.attributes[\"src.address\"], \".*\\\\.cluster\\\\.local$\")) and not(IsMatch(datapoint.attributes[\"src.address\"], \"^(https?://)?\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+(:\\\\d+)?$\"))\n\n          # Temporary, to be removed when solarwindsentityconnector supports creation of entities from attributes with prefixes\n          - set(datapoint.attributes[\"sw.server.address.fqdn\"], datapoint.attributes[\"sw.k8s.dst.sw.server.address.fqdn\"]) where datapoint.attributes[\"sw.k8s.dst.sw.server.address.fqdn\"] != nil\n          - set(datapoint.attributes[\"sw.server.address.fqdn\"], datapoint.attributes[\"sw.k8s.src.sw.server.address.fqdn\"]) where datapoint.attributes[\"sw.k8s.src.sw.server.address.fqdn\"] != nil\n\n  transform/beyla-entity-ids:\n    metric_statements:\n      - keep_keys(resource.attributes, [\"sw.k8s.workload.type\", \"sw.k8s.workload.name\", \"sw.k8s.workload.namespace\", \"sw.k8s.dst.workload.type\", \"sw.k8s.dst.workload.name\", \"sw.k8s.dst.workload.namespace\", \"sw.k8s.src.workload.type\", \"sw.k8s.src.workload.name\", \"sw.k8s.src.workload.namespace\", \"sw.k8s.dst.sw.server.address.fqdn\", \"sw.k8s.src.sw.server.address.fqdn\", \"sw.server.address.fqdn\"])\n\n      - set(resource.attributes[\"sw.k8s.src.k8s.deployment.name\"], resource.attributes[\"sw.k8s.src.workload.name\"]) where resource.attributes[\"sw.k8s.src.workload.type\"] == \"Deployment\" and resource.attributes[\"sw.k8s.src.workload.name\"] != nil\n      - set(resource.attributes[\"sw.k8s.src.k8s.statefulset.name\"], resource.attributes[\"sw.k8s.src.workload.name\"]) where resource.attributes[\"sw.k8s.src.workload.type\"] == \"StatefulSet\" and resource.attributes[\"sw.k8s.src.workload.name\"] != nil\n      - set(resource.attributes[\"sw.k8s.src.k8s.daemonset.name\"], resource.attributes[\"sw.k8s.src.workload.name\"]) where resource.attributes[\"sw.k8s.src.workload.type\"] == \"DaemonSet\" and resource.attributes[\"sw.k8s.src.workload.name\"] != nil\n      - set(resource.attributes[\"sw.k8s.src.k8s.service.name\"], resource.attributes[\"sw.k8s.src.workload.name\"]) where resource.attributes[\"sw.k8s.src.workload.type\"] == \"Service\" and resource.attributes[\"sw.k8s.src.workload.name\"] != nil\n      - set(resource.attributes[\"sw.k8s.src.k8s.job.name\"], resource.attributes[\"sw.k8s.src.workload.name\"]) where resource.attributes[\"sw.k8s.src.workload.type\"] == \"Job\" and resource.attributes[\"sw.k8s.src.workload.name\"] != nil\n      - set(resource.attributes[\"sw.k8s.src.k8s.node.name\"], resource.attributes[\"sw.k8s.src.workload.name\"]) where resource.attributes[\"sw.k8s.src.workload.type\"] == \"Node\" and resource.attributes[\"sw.k8s.src.workload.name\"] != nil\n      - set(resource.attributes[\"sw.k8s.src.k8s.pod.name\"], resource.attributes[\"sw.k8s.src.workload.name\"]) where resource.attributes[\"sw.k8s.src.workload.type\"] == \"Pod\" and resource.attributes[\"sw.k8s.src.workload.name\"] != nil\n      - set(resource.attributes[\"sw.k8s.src.k8s.namespace.name\"], resource.attributes[\"sw.k8s.src.workload.namespace\"]) where resource.attributes[\"sw.k8s.src.workload.namespace\"] != nil\n\n      - set(resource.attributes[\"sw.k8s.dst.k8s.deployment.name\"], resource.attributes[\"sw.k8s.dst.workload.name\"]) where resource.attributes[\"sw.k8s.dst.workload.type\"] == \"Deployment\" and resource.attributes[\"sw.k8s.dst.workload.name\"] != nil\n      - set(resource.attributes[\"sw.k8s.dst.k8s.statefulset.name\"], resource.attributes[\"sw.k8s.dst.workload.name\"]) where resource.attributes[\"sw.k8s.dst.workload.type\"] == \"StatefulSet\" and resource.attributes[\"sw.k8s.dst.workload.name\"] != nil\n      - set(resource.attributes[\"sw.k8s.dst.k8s.daemonset.name\"], resource.attributes[\"sw.k8s.dst.workload.name\"]) where resource.attributes[\"sw.k8s.dst.workload.type\"] == \"DaemonSet\" and resource.attributes[\"sw.k8s.dst.workload.name\"] != nil\n      - set(resource.attributes[\"sw.k8s.dst.k8s.service.name\"], resource.attributes[\"sw.k8s.dst.workload.name\"]) where resource.attributes[\"sw.k8s.dst.workload.type\"] == \"Service\" and resource.attributes[\"sw.k8s.dst.workload.name\"] != nil\n      - set(resource.attributes[\"sw.k8s.dst.k8s.job.name\"], resource.attributes[\"sw.k8s.dst.workload.name\"]) where resource.attributes[\"sw.k8s.dst.workload.type\"] == \"Job\" and resource.attributes[\"sw.k8s.dst.workload.name\"] != nil\n      - set(resource.attributes[\"sw.k8s.dst.k8s.node.name\"], resource.attributes[\"sw.k8s.dst.workload.name\"]) where resource.attributes[\"sw.k8s.dst.workload.type\"] == \"Node\" and resource.attributes[\"sw.k8s.dst.workload.name\"] != nil\n      - set(resource.attributes[\"sw.k8s.dst.k8s.pod.name\"], resource.attributes[\"sw.k8s.dst.workload.name\"]) where resource.attributes[\"sw.k8s.dst.workload.type\"] == \"Pod\" and resource.attributes[\"sw.k8s.dst.workload.name\"] != nil\n      - set(resource.attributes[\"sw.k8s.dst.k8s.namespace.name\"], resource.attributes[\"sw.k8s.dst.workload.namespace\"]) where resource.attributes[\"sw.k8s.dst.workload.namespace\"] != nil\n\n      - set(resource.attributes[\"sw.k8s.src.k8s.deployment.name\"], resource.attributes[\"sw.k8s.workload.name\"]) where resource.attributes[\"sw.k8s.workload.type\"] == \"Deployment\" and resource.attributes[\"sw.k8s.workload.name\"] != nil and resource.attributes[\"sw.k8s.dst.workload.name\"] != nil\n      - set(resource.attributes[\"sw.k8s.src.k8s.statefulset.name\"], resource.attributes[\"sw.k8s.workload.name\"]) where resource.attributes[\"sw.k8s.workload.type\"] == \"StatefulSet\" and resource.attributes[\"sw.k8s.workload.name\"] != nil and resource.attributes[\"sw.k8s.dst.workload.name\"] != nil\n      - set(resource.attributes[\"sw.k8s.src.k8s.daemonset.name\"], resource.attributes[\"sw.k8s.workload.name\"]) where resource.attributes[\"sw.k8s.workload.type\"] == \"DaemonSet\" and resource.attributes[\"sw.k8s.workload.name\"] != nil and resource.attributes[\"sw.k8s.dst.workload.name\"] != nil\n      - set(resource.attributes[\"sw.k8s.src.k8s.service.name\"], resource.attributes[\"sw.k8s.workload.name\"]) where resource.attributes[\"sw.k8s.workload.type\"] == \"Service\" and resource.attributes[\"sw.k8s.workload.name\"] != nil and resource.attributes[\"sw.k8s.dst.workload.name\"] != nil\n      - set(resource.attributes[\"sw.k8s.src.k8s.job.name\"], resource.attributes[\"sw.k8s.workload.name\"]) where resource.attributes[\"sw.k8s.workload.type\"] == \"Job\" and resource.attributes[\"sw.k8s.workload.name\"] != nil and resource.attributes[\"sw.k8s.dst.workload.name\"] != nil\n      - set(resource.attributes[\"sw.k8s.src.k8s.node.name\"], resource.attributes[\"sw.k8s.workload.name\"]) where resource.attributes[\"sw.k8s.workload.type\"] == \"Node\" and resource.attributes[\"sw.k8s.workload.name\"] != nil and resource.attributes[\"sw.k8s.dst.workload.name\"] != nil\n      - set(resource.attributes[\"sw.k8s.src.k8s.pod.name\"], resource.attributes[\"sw.k8s.workload.name\"]) where resource.attributes[\"sw.k8s.workload.type\"] == \"Pod\" and resource.attributes[\"sw.k8s.workload.name\"] != nil and resource.attributes[\"sw.k8s.dst.workload.name\"] != nil\n      - set(resource.attributes[\"sw.k8s.src.k8s.namespace.name\"], resource.attributes[\"sw.k8s.workload.namespace\"]) where resource.attributes[\"sw.k8s.workload.namespace\"] != nil and resource.attributes[\"sw.k8s.dst.workload.name\"] != nil\n\n      - set(resource.attributes[\"sw.k8s.dst.k8s.deployment.name\"], resource.attributes[\"sw.k8s.workload.name\"]) where resource.attributes[\"sw.k8s.workload.type\"] == \"Deployment\" and resource.attributes[\"sw.k8s.workload.name\"] != nil and resource.attributes[\"sw.k8s.src.workload.name\"] != nil\n      - set(resource.attributes[\"sw.k8s.dst.k8s.statefulset.name\"], resource.attributes[\"sw.k8s.workload.name\"]) where resource.attributes[\"sw.k8s.workload.type\"] == \"StatefulSet\" and resource.attributes[\"sw.k8s.workload.name\"] != nil and resource.attributes[\"sw.k8s.src.workload.name\"] != nil\n      - set(resource.attributes[\"sw.k8s.dst.k8s.daemonset.name\"], resource.attributes[\"sw.k8s.workload.name\"]) where resource.attributes[\"sw.k8s.workload.type\"] == \"DaemonSet\" and resource.attributes[\"sw.k8s.workload.name\"] != nil and resource.attributes[\"sw.k8s.src.workload.name\"] != nil\n      - set(resource.attributes[\"sw.k8s.dst.k8s.service.name\"], resource.attributes[\"sw.k8s.workload.name\"]) where resource.attributes[\"sw.k8s.workload.type\"] == \"Service\" and resource.attributes[\"sw.k8s.workload.name\"] != nil and resource.attributes[\"sw.k8s.src.workload.name\"] != nil\n      - set(resource.attributes[\"sw.k8s.dst.k8s.job.name\"], resource.attributes[\"sw.k8s.workload.name\"]) where resource.attributes[\"sw.k8s.workload.type\"] == \"Job\" and resource.attributes[\"sw.k8s.workload.name\"] != nil and resource.attributes[\"sw.k8s.src.workload.name\"] != nil\n      - set(resource.attributes[\"sw.k8s.dst.k8s.node.name\"], resource.attributes[\"sw.k8s.workload.name\"]) where resource.attributes[\"sw.k8s.workload.type\"] == \"Node\" and resource.attributes[\"sw.k8s.workload.name\"] != nil and resource.attributes[\"sw.k8s.src.workload.name\"] != nil\n      - set(resource.attributes[\"sw.k8s.dst.k8s.pod.name\"], resource.attributes[\"sw.k8s.workload.name\"]) where resource.attributes[\"sw.k8s.workload.type\"] == \"Pod\" and resource.attributes[\"sw.k8s.workload.name\"] != nil and resource.attributes[\"sw.k8s.src.workload.name\"] != nil\n      - set(resource.attributes[\"sw.k8s.dst.k8s.namespace.name\"], resource.attributes[\"sw.k8s.workload.namespace\"]) where resource.attributes[\"sw.k8s.workload.namespace\"] != nil and resource.attributes[\"sw.k8s.src.workload.name\"] != nil\n\n  groupbyattrs/beyla-entity-ids:\n    keys:\n      - sw.k8s.dst.sw.server.address.fqdn\n      - sw.k8s.src.sw.server.address.fqdn\n      - sw.server.address.fqdn\n      - sw.k8s.dst.workload.type\n      - sw.k8s.dst.workload.name\n      - sw.k8s.dst.workload.namespace\n      - sw.k8s.src.workload.type\n      - sw.k8s.src.workload.name\n      - sw.k8s.src.workload.namespace\n\nreceivers:\n  otlp:\n    protocols:\n      grpc:\n        endpoint: 0.0.0.0:4317\n      http:\n        endpoint: 0.0.0.0:4318\n\nconnectors:\n  forward/metrics_common: {}\n  routing/metrics:\n    default_pipelines: [metrics]\n    table:\n      - context: metric\n        pipelines:\n          - metrics/beyla\n          - metrics/beyla-network-entities-and-relationships\n        condition: |\n          name == \"http.client.request.duration\" or\n          name == \"http.client.request.body.size\" or\n          name == \"http.client.response.body.size\" or\n          name == \"http.server.request.duration\" or \n          name == \"http.server.request.body.size\" or\n          name == \"http.server.response.body.size\" or\n          name == \"rpc.client.duration\" or\n          name == \"rpc.server.duration\" or\n          name == \"sql.client.duration\" or\n          name == \"redis.client.duration\" or\n          name == \"messaging.publish.duration\" or\n          name == \"messaging.process.duration\" or\n          name == \"process.cpu.time\" or\n          name == \"process.cpu.utilization\" or\n          name == \"process.memory.usage\" or\n          name == \"process.memory.virtual\" or\n          name == \"process.disk.io\" or\n          name == \"process.network.io\" or\n          name == \"beyla.network.flow.bytes\" or\n          name == \"beyla.network.inter.zone.bytes\"\n\n  solarwindsentity/beyla-relationships:\n    source_prefix: \"sw.k8s.src.\"\n    destination_prefix: \"sw.k8s.dst.\"\n    schema:\n      entities:\n        - entity: KubernetesDeployment\n          id:\n            - sw.k8s.cluster.uid\n            - k8s.namespace.name\n            - k8s.deployment.name\n        - entity: KubernetesStatefulSet\n          id:\n            - sw.k8s.cluster.uid\n            - k8s.namespace.name\n            - k8s.statefulset.name\n        - entity: KubernetesDaemonSet\n          id:\n            - sw.k8s.cluster.uid\n            - k8s.namespace.name\n            - k8s.daemonset.name\n        - entity: KubernetesJob\n          id:\n            - sw.k8s.cluster.uid\n            - k8s.namespace.name\n            - k8s.job.name\n        - entity: KubernetesCronJob\n          id:\n            - sw.k8s.cluster.uid\n            - k8s.namespace.name\n            - k8s.cronjob.name\n        - entity: KubernetesService\n          id:\n            - sw.k8s.cluster.uid\n            - k8s.namespace.name\n            - k8s.service.name\n        - entity: KubernetesPod\n          id:\n            - sw.k8s.cluster.uid\n            - k8s.namespace.name\n            - k8s.pod.name\n        - entity: KubernetesNode\n          id:\n            - sw.k8s.cluster.uid\n            - k8s.node.name\n        - entity: PublicNetworkLocation\n          id:\n            - sw.server.address.fqdn\n      events:\n        relationships:\n          # source KubernetesDeployment\n          - type: KubernetesCommunicatesWith\n            source_entity: KubernetesDeployment\n            destination_entity: KubernetesService\n            conditions: []\n            context: \"metric\"\n            attributes:\n          - type: KubernetesCommunicatesWith\n            source_entity: KubernetesDeployment\n            destination_entity: PublicNetworkLocation\n            conditions: []\n            context: \"metric\"\n            attributes:\n          - type: KubernetesCommunicatesWith\n            source_entity: KubernetesDeployment\n            destination_entity: KubernetesDeployment\n            conditions: []\n            context: \"metric\"\n            attributes:\n          - type: KubernetesCommunicatesWith\n            source_entity: KubernetesDeployment\n            destination_entity: KubernetesStatefulSet\n            conditions: []\n            context: \"metric\"\n            attributes:\n          - type: KubernetesCommunicatesWith\n            source_entity: KubernetesDeployment\n            destination_entity: KubernetesDaemonSet\n            conditions: []\n            context: \"metric\"\n            attributes:\n          - type: KubernetesCommunicatesWith\n            source_entity: KubernetesDeployment\n            destination_entity: KubernetesNode\n            conditions: []\n            context: \"metric\"\n            attributes:\n          - type: KubernetesCommunicatesWith\n            source_entity: KubernetesDeployment\n            destination_entity: KubernetesPod\n            conditions: []\n            context: \"metric\"\n            attributes:\n          # source KubernetesStatefulSet\n          - type: KubernetesCommunicatesWith\n            source_entity: KubernetesStatefulSet\n            destination_entity: KubernetesService\n            conditions: []\n            context: \"metric\"\n            attributes:\n          - type: KubernetesCommunicatesWith\n            source_entity: KubernetesStatefulSet\n            destination_entity: PublicNetworkLocation\n            conditions: []\n            context: \"metric\"\n            attributes:\n          - type: KubernetesCommunicatesWith\n            source_entity: KubernetesStatefulSet\n            destination_entity: KubernetesDeployment\n            conditions: []\n            context: \"metric\"\n            attributes:\n          - type: KubernetesCommunicatesWith\n            source_entity: KubernetesStatefulSet\n            destination_entity: KubernetesStatefulSet\n            conditions: []\n            context: \"metric\"\n            attributes:\n          - type: KubernetesCommunicatesWith\n            source_entity: KubernetesStatefulSet\n            destination_entity: KubernetesDaemonSet\n            conditions: []\n            context: \"metric\"\n            attributes:\n          - type: KubernetesCommunicatesWith\n            source_entity: KubernetesStatefulSet\n            destination_entity: KubernetesNode\n            conditions: []\n            context: \"metric\"\n            attributes:\n          - type: KubernetesCommunicatesWith\n            source_entity: KubernetesStatefulSet\n            destination_entity: KubernetesPod\n            conditions: []\n            context: \"metric\"\n            attributes:\n          # source KubernetesDaemonSet\n          - type: KubernetesCommunicatesWith\n            source_entity: KubernetesDaemonSet\n            destination_entity: KubernetesService\n            conditions: []\n            context: \"metric\"\n            attributes:\n          - type: KubernetesCommunicatesWith\n            source_entity: KubernetesDaemonSet\n            destination_entity: PublicNetworkLocation\n            conditions: []\n            context: \"metric\"\n            attributes:\n          - type: KubernetesCommunicatesWith\n            source_entity: KubernetesDaemonSet\n            destination_entity: KubernetesDeployment\n            conditions: []\n            context: \"metric\"\n            attributes:\n          - type: KubernetesCommunicatesWith\n            source_entity: KubernetesDaemonSet\n            destination_entity: KubernetesStatefulSet\n            conditions: []\n            context: \"metric\"\n            attributes:\n          - type: KubernetesCommunicatesWith\n            source_entity: KubernetesDaemonSet\n            destination_entity: KubernetesDaemonSet\n            conditions: []\n            context: \"metric\"\n            attributes:\n          - type: KubernetesCommunicatesWith\n            source_entity: KubernetesDaemonSet\n            destination_entity: KubernetesNode\n            conditions: []\n            context: \"metric\"\n            attributes:\n          - type: KubernetesCommunicatesWith\n            source_entity: KubernetesDaemonSet\n            destination_entity: KubernetesPod\n            conditions: []\n            context: \"metric\"\n            attributes:\n          # source KubernetesJob\n          - type: KubernetesCommunicatesWith\n            source_entity: KubernetesJob\n            destination_entity: KubernetesService\n            conditions: []\n            context: \"metric\"\n            attributes:\n          - type: KubernetesCommunicatesWith\n            source_entity: KubernetesJob\n            destination_entity: PublicNetworkLocation\n            conditions: []\n            context: \"metric\"\n            attributes:\n          - type: KubernetesCommunicatesWith\n            source_entity: KubernetesJob\n            destination_entity: KubernetesDeployment\n            conditions: []\n            context: \"metric\"\n            attributes:\n          - type: KubernetesCommunicatesWith\n            source_entity: KubernetesJob\n            destination_entity: KubernetesStatefulSet\n            conditions: []\n            context: \"metric\"\n            attributes:\n          - type: KubernetesCommunicatesWith\n            source_entity: KubernetesJob\n            destination_entity: KubernetesJob\n            conditions: []\n            context: \"metric\"\n            attributes:\n          - type: KubernetesCommunicatesWith\n            source_entity: KubernetesJob\n            destination_entity: KubernetesNode\n            conditions: []\n            context: \"metric\"\n            attributes:\n          - type: KubernetesCommunicatesWith\n            source_entity: KubernetesJob\n            destination_entity: KubernetesPod\n            conditions: []\n            context: \"metric\"\n            attributes:\n\n  solarwindsentity/beyla-entities:\n    schema:\n      entities:\n        - entity: PublicNetworkLocation\n          id:\n            - sw.server.address.fqdn\n      events:\n        entities:\n          - type: \"PublicNetworkLocation\"\n            context: \"metric\"\n\nservice:\n  extensions:\n    - health_check\n  pipelines:\n    metrics/common_in:\n      exporters:\n        - routing/metrics\n      processors:\n        - memory_limiter\n      receivers:\n        - otlp\n    metrics:\n      exporters:\n        - forward/metrics_common\n      processors:\n        - memory_limiter\n        - filter/histograms\n      receivers:\n        - routing/metrics\n    metrics/beyla:\n      exporters:\n        - forward/metrics_common\n      processors:\n        - memory_limiter\n      receivers:\n        - routing/metrics\n    metrics/common_out:\n      exporters:\n        - otlp\n      processors:\n        - memory_limiter\n        - k8sattributes\n        - metricstransform/rename\n        - attributes/clean-attributes-otlp-metrics\n        - resource\n        - transform/scope\n        - batch\n      receivers:\n        - forward/metrics_common\n    logs:\n      exporters:\n        - otlp\n      processors:\n        - memory_limiter\n        - k8sattributes\n        - resource\n        - transform/scope\n        - batch\n      receivers:\n        - otlp\n    traces:\n      exporters:\n        - otlp\n      processors:\n        - memory_limiter\n        - k8sattributes\n        - resource\n        - transform/scope\n        - batch\n      receivers:\n        - otlp\n\n    # Current SWO pipeline cannot process state events and relationships events together,\n    # so we need to split them into two separate pipelines.\n    # TODO - merge 'logs/beyla-stateevents-entities' and 'logs/beyla-stateevents-relationships' into one pipeline when SWO supports it.\n    metrics/beyla-network-entities-and-relationships:\n      exporters:\n        - solarwindsentity/beyla-relationships\n        - solarwindsentity/beyla-entities\n      processors:\n        - memory_limiter\n        # - filter/beyla_test\n        - swok8sworkloadtype/beyla\n        - transform/beyla-fqdn-attribute\n        - groupbyattrs/beyla-entity-ids\n        - transform/beyla-entity-ids\n        - resource\n      receivers:\n        - routing/metrics\n    logs/beyla-stateevents-entities:\n      exporters:\n        - otlp\n      processors:\n        - memory_limiter\n        - transform/scope\n        - batch\n      receivers:\n        - solarwindsentity/beyla-entities\n    logs/beyla-stateevents-relationships:\n      exporters:\n        - otlp\n      processors:\n        - memory_limiter\n        - transform/scope\n        - batch\n      receivers:\n        - solarwindsentity/beyla-relationships\n\n  telemetry:\n    logs:\n      level: info\n    metrics:\n      readers:\n        - pull:\n            exporter:\n              prometheus:\n                host: \"0.0.0.0\"\n                port: 8888"
